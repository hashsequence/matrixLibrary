"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const reporters_1 = require("@jest/reporters");
const chalk_1 = __importDefault(require("chalk"));
const ndjson_1 = __importDefault(require("ndjson"));
const formatPeriod = (num) => {
    if (num < Math.pow(10, -6)) {
        return `${(num * Math.pow(10, 6)).toFixed(3)} Î¼s`;
    }
    else if (num < Math.pow(10, -3)) {
        return `${(num * Math.pow(10, 3)).toFixed(3)} ms`;
    }
    else if (num < 1) {
        return `${(num * Math.pow(10, 3)).toFixed(2)} ms`;
    }
    return `${num.toFixed(2)} s`;
};
class BenchmarkReporter extends reporters_1.BaseReporter {
    constructor(globalConfig) {
        super();
        this._globalConfig = globalConfig;
        this._rootDir = globalConfig.rootDir;
    }
    onRunStart(results, options) {
        super.onRunStart(results, options);
        const name = this.resultFile;
        if (fs.existsSync(name)) {
            fs.writeFileSync(name, "");
        }
    }
    get resultFile() {
        return path.join(this._rootDir, "benchmarks", "result.txt");
    }
    onRunComplete() {
        this.log(`${chalk_1.default.bold("Benchmarks:")}`);
        return new Promise((resolve, reject) => {
            fs.createReadStream(this.resultFile)
                .pipe(ndjson_1.default.parse())
                .on("data", (obj) => {
                for (let suiteName in obj) {
                    const suite = obj[suiteName];
                    this.log(`  ${suiteName}`);
                    const lines = [];
                    for (let [name, bench] of suite) {
                        const { stats, times } = bench;
                        const { rme, sample } = stats;
                        const size = sample.length;
                        const { period } = times;
                        lines.push([
                            name,
                            `${chalk_1.default.green(formatPeriod(period))} \xb1`,
                            chalk_1.default.cyan(`${rme.toFixed(2)} %`),
                            `(${size} run${size == 1 ? " " : "s"} sampled)`,
                        ]);
                    }
                    const maxWidths = lines.reduce((prev, cur) => cur.map((v, i) => {
                        if (!prev[i] || prev[i] < v.length)
                            return v.length;
                        return prev[i];
                    }), []);
                    for (let line of lines) {
                        this.log("    " + line.map((v, i) => {
                            const w = maxWidths[i];
                            return i === 0 ? v.padEnd(w) : v.padStart(w);
                        }).join("  "));
                    }
                }
            })
                .on("error", (error) => {
                reject(error);
            })
                .on("end", () => {
                resolve();
            });
        });
    }
}
exports.default = BenchmarkReporter;
//# sourceMappingURL=reporter.js.map